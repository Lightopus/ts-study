// 类型检查机制 -- 
/*
概念: ts 编译器在做类型检查的时候,所秉承的一些原则, 以及表现出的 一些行为
作用: 辅助开发, 提高开发效率
类型: 1. 类型推断
      2. 类型兼容
      3. 类型保护
*/
// 类型推断 
/*
概念: 不需要指定变量的类型 (函数的返回值类型) ts可以根据某些规则自动的为其推断出 一个类型
类别:
  1.1 基础类型推断
  1.2 最佳通用类型推断
  1.3 上下文类型推断
*/
// 1.1 类型检查机制--类型推断--基础类型推断(常见,场景:初始化变量,设置函数默认参数时候)(从右到到左)
// 场景:初始化变量
let a; // 推断为:any类型
let b = 1; // 推断为:number类型;
let c = [] // 推断为: 以any类型为元素的 数组类型
let d = [1] // 推断为: 以number类型为元素的 数组类型
// ....

// 设置函数默认参数时候
let aa = (x = 1) => {} // x被推断为 number类型
let bb = (x = 1) => x + 1 // bb被推断为 number类型

// 类型检查机制--类型推断-- 最佳通用类型推断(从右到到左)
/*
概念: 当需要从多个类型中推断出 一个类型的时候,那么这个类型就是 最佳通用类型推断
*/
let bbb = [1, null] // 推断为:联合类型(number | null) (number和null 不兼容)
// 注意:tsconfig.json文件中=> "strictNullChecks": false, 
// null 和number 就兼容了 bbb被推断为 number类型的数组;

// 类型检查机制--类型推断-- 上下文类型推断(从左到到右,一般发生在事件处理阶段)
window.onkeydown = () => {
  console.log(event)
}

// 如果ts 类型推断 不符合需要,可以使用类型断言
interface Foo {
  bar: number;
}
// let foo = {} as Foo //类型断言 ,要避免滥用 ,最好是 声明的时候 指定类型
let foo: Foo = {
  bar: 1
}
foo.bar = 1

// 2. 类型兼容

